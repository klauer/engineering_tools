#!/reg/g/pcds/pyps/conda/py39/envs/pcds-5.3.1/bin/python

from __future__ import annotations

import argparse
import dataclasses
import json
import os
import requests
import socket
import sys

from typing import Dict, List, Optional

WS_URL = "https://pswww.slac.stanford.edu/ws/lgbk"
DATA_PATH = "/cds/group/psdm/"
UNKNOWN_HUTCH = "unknown_hutch"

hutches = [
    "tmo",
    "txi",
    "rix",
    "xpp",
    "xcs",
    "mfx",
    "cxi",
    "mec",
    "ued",
    "det",
    "lfe",
    "kfe",
    "tst",
    "las",
    "hpl",
]

# populate hutch-specific subnets here:
hutch_subnets = {
    "tmo": ["28", "132", "133", "134", "135"],
    "txi": ["29", "136", "137", "138", "139"],
    "rix": ["31", "144", "145", "146", "147"],
    "xpp": ["22", "84", "85", "86", "87"],
    "xcs": ["25", "80", "81", "82", "83"],
    "cxi": ["26", "68", "69", "70", "71"],
    "mfx": ["24", "72", "73", "74", "75"],
    "mec": ["27", "76", "77", "78", "79"],
    "ued": ["36"],
    "det": ["58", "59"],
    "lfe": ["88", "89", "90", "91"],
    "kfe": ["92", "93", "94", "95"],
    "tst": ["23", "148", "149", "150", "151"],
    "las": ["35", "160", "161", "162", "163"],
    "hpl": ["64"],
}


@dataclasses.dataclass
class _LogbookInfo:
    @classmethod
    def _response_to_instance(cls, response: Optional[dict]):
        if response is None:
            return cls()

        fields = dataclasses.fields(cls)
        info = response.get("value", {}) or {}
        kwargs = {field.name: info.get(field.name, "") for field in fields}
        kwargs["valid"] = response.get("success", False)
        return cls(**kwargs)


@dataclasses.dataclass
class Experiment(_LogbookInfo):
    valid: bool = False
    name: str = ""
    description: str = ""
    start_time: str = ""
    end_time: str = ""
    leader_account: str = ""
    contact_info: str = ""
    posix_group: str = ""
    params: Dict[str, str] = dataclasses.field(default_factory=dict)

    @classmethod
    def from_logbook(
        cls, instrument: Instrument, experiment_name: Optional[str] = None
    ) -> Experiment:
        # TODO: how do we get information about a given experiment?
        try:
            resp = requests.get(
                WS_URL + "/lgbk/ws/activeexperiment_for_instrument_station",
                dict(instrument_name=instrument.hutch, station=instrument.station),
            ).json()
        except Exception:
            return cls()

        return cls._response_to_instance(resp)


@dataclasses.dataclass
class RunFiles(_LogbookInfo):
    valid: bool = False
    files: List[str] = dataclasses.field(default_factory=list)
    num_files: int = 0

    @classmethod
    def from_logbook(cls, experiment: Experiment, run: Run) -> RunFiles:
        try:
            resp = requests.get(
                f"{WS_URL}/lgbk/{experiment.name}/ws/{run.num}/files_for_live_mode"
            )
            info = resp.json()
        except Exception:
            return RunFiles(valid=False)

        valid = info.get("success", False)
        files = [DATA_PATH + fn.lstrip("/") for fn in info.get("value", [])]
        run_files = RunFiles(valid=valid, files=files)
        run_files.num_files = cls._get_num_files(run_files.files)
        return run_files

    @staticmethod
    def _get_num_files(files: List[str]) -> int:
        num_files = 0
        for fn in files:
            if "c00" in fn and "-s8" not in fn:
                num_files += 1
        return num_files


@dataclasses.dataclass
class Run(_LogbookInfo):
    valid: bool = False
    live: bool = False
    num: int = 0
    type: str = ""
    begin_time: str = ""
    end_time: str = ""
    params: Dict[str, str] = dataclasses.field(default_factory=dict)
    editable_params: Dict[str, str] = dataclasses.field(default_factory=dict)
    files: RunFiles = dataclasses.field(default_factory=RunFiles)

    @classmethod
    def from_logbook(cls, experiment: Experiment) -> Run:
        try:
            resp = requests.get(
                f"{WS_URL}/lgbk/{experiment.name}/ws/current_run"
            ).json()
        except Exception:
            return cls(valid=False)

        run = cls._response_to_instance(resp)
        run.live = bool(run.end_time)
        run.files = RunFiles.from_logbook(experiment, run)
        return run


@dataclasses.dataclass
class Instrument:
    hutch: str
    daq_base: str = ""
    instrument: str = ""
    station: int = 0
    config_filename: str = ""
    nstations: int = 0
    station_valid: bool = False
    experiment: Experiment = dataclasses.field(default_factory=Experiment)
    run: Run = dataclasses.field(default_factory=Run)

    def fix_parameters(self, ended: bool = False) -> None:
        if ended:
            if not self.run.valid or not self.run.end_time:
                # Really bogus way to determine this; but copying over from previous code.
                self.run.num -= 1

    @classmethod
    def from_hutch(cls, hutch: str, station: Optional[int] = None) -> Instrument:
        info = cls(hutch=hutch)

        # if hutch.lower() in ['mfx','cxi']:
        if hutch.lower() in ["cxi"]:
            info.nstations = 2
            if station is not None:
                info.station = int(station)
            elif is_monitor_host(socket.gethostname()):
                info.station = 1
            else:
                info.station = 0
            info.daq_base = f"{hutch.lower()}_{info.station}"
            info.instrument = f"{hutch.upper()}:{info.station}"
        elif hutch.lower() in ["rix"]:
            info.station = 2
        else:
            info.daq_base = hutch.lower()
            info.instrument = hutch.upper()
            info.nstations = 1
            if station:
                info.station = int(station)
            else:
                info.station = 0

        info.station_valid = not info._is_station_invalid()
        if info.daq_base:
            info.config_filename = f"{info.daq_base}.cnf"
        return info

    def update_from_logbook(self, experiment: Optional[str] = None):
        self.experiment = Experiment.from_logbook(self)
        self.run = Run.from_logbook(self.experiment)

    def _is_station_invalid(self):
        return self.hutch.lower() != "rix" and self.station >= self.nstations


def create_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser()
    parser.add_argument("--hutch", help="get experiment for hutch xxx")
    parser.add_argument(
        "--station", help="optional station for hutch with two daqs, e.g. cxi and mfx"
    )
    parser.add_argument("--ended", help="ended", action="store_true")
    parser.add_argument("--setExp", "--experiment", help="set experiment name")
    return parser


def get_hutch_by_hostname() -> str:
    hostname = socket.gethostname()
    ip = socket.gethostbyname(hostname)
    subnet = ip.split(".")[2]

    for ihutch in hutches:  # use the IP address to match the host to a hutch by subnet
        if subnet in hutch_subnets.get(ihutch, []):
            return ihutch.upper()

    for ihutch in hutches:
        if ihutch in hostname:
            return ihutch.upper()

    if "psusr13" in hostname:
        return "XPP"
    if "psusr21" in hostname:
        return "XCS"
    if "psusr22" in hostname:
        return "CXI"
    if "psusr23" in hostname:
        return "MEC"
    if "psusr24" in hostname:
        return "MFX"

    # then check current path
    path = os.getcwd()
    for ihutch in hutches:
        if path.find(ihutch) >= 0:
            return ihutch.upper()

    # because we have so many names for the same subnet.
    if ("xrt" in path and "xrt" in hostname) or ("xtod" in path and "xtod" in hostname):
        return "LFE"

    return UNKNOWN_HUTCH


def is_monitor_host(hostname: str) -> bool:
    return "monitor" in hostname


def fix_hutch_name(hutch: str) -> str:
    if hutch in hutches:
        return hutch.upper()

    for ihutch in hutches:
        if hutch.find(ihutch.upper()) >= 0:
            return ihutch.upper()

    return UNKNOWN_HUTCH


def get_info(args):
    if args.hutch:
        hutch = fix_hutch_name(args.hutch)
    else:
        hutch = get_hutch_by_hostname()

    if hutch == UNKNOWN_HUTCH:
        print(UNKNOWN_HUTCH)
        sys.exit()

    instrument = Instrument.from_hutch(hutch, args.station)
    instrument.fix_parameters(ended=args.ended)
    return instrument


def main():
    parser = create_arg_parser()
    args = parser.parse_args()
    info = get_info(args)
    info.update_from_logbook()
    print(json.dumps(dataclasses.asdict(info), indent=4))


if __name__ == "__main__":
    main()
